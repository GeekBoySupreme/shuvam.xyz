<!-- Start header block from here -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
<title>Reading between the lines</title>
<link rel="stylesheet" href="../article-style.css"/>
<link rel="icon" href="../../favicon.ico">

<script src="https://kit.fontawesome.com/622afd0c30.js" crossorigin="anonymous"></script>
</head>

<body>
<!-- Copy till here -->
<article id="67795472-d835-4f5b-8834-c65c0c98c646" class="page sans"><header><img class="page-cover-image" src="https://cdn.britannica.com/40/96240-050-142CC589/flying-machine-Leonardo-da-Vinci-plans-ornithopter.jpg" style="object-position:center 54.400000000000006%"/><div class="page-header-icon page-header-icon-with-cover"><img class="icon" src="Reading%20between%20the%20lines%2067795472d8354f5b8834c65c0c98c646/Ellipse_1.png"/></div><h1 class="page-title">Reading between the lines</h1><p class="page-description"></p></header><div class="page-body"><ul id="fda71be1-7537-46b9-bf5d-c5a455aa202d" class="block-color-orange bulleted-list"><li style="list-style-type:disc">Originally authored ‚éØ June 6, 2021</li></ul><hr id="57111731-a618-41a2-93c2-fc1a8f000292"/><p id="ccc07c35-c3df-442f-8046-9f09049807d4" class="">The value of a computer does not stem from its inherent capacity to do things well ‚éØ it stems from an operator‚Äôs capacity to elucidate and structure what we want from the computer, it stems from a quiet conviction that this computer can do umpteen mathematical calculations faster than me, better, with more accuracy and speed I can only imagine of. </p><p id="77fc95b9-007a-4a86-a073-8037df8e4d26" class="">That very notion shows us what we can do with computers is often limited by the depths to which we can think creatively, transcribe these thoughts into coherent and articulated steps/instructions, and then share that work with others. Often, due to this, tools that leverage the power of collaborative creation hold immeasurable power to architect the way we communicate, articulate ideas, and translate that into knowledge forms understandable to completely different stakeholders ‚éØ and this thesis seeks to explore newer paradigms of interacting with programs that leverage GPT-3‚Äôs articulate text generation capabilities to craft a semblance of <code>human intuition</code> for software, an experimental simulation that seeks to answer a fundamental question - ‚Äú<em>What if software could infer what the operator wants to do, and present to them the tools to get it done, without the operator‚Äôs explicit intervention?‚Äù</em></p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="0fc6e110-dec1-4103-85ff-fbcaf4e40f59"><div style="font-size:1.5em"><span class="icon">üöß</span></div><div style="width:100%">Note that this thesis was authored in early June 2021 (and the latest model from OpenAI was <mark class="highlight-red">GPT-3</mark>).<br/>Function calling and JSON output were released with GPT-3.5 and above much later in mid-2023. Most of the approaches and monkey patches you‚Äôd find below are unnecessary in the face of recent updates to GPT.<br/></div></figure><br/><h2 id="18b4db3e-04e5-4dbb-95af-69e8a78bdf58" class="">Early tools</h2><hr id="a0db579f-1cf9-4cad-98f3-e5317db6a757"/><p id="54f6a75b-f743-45b4-9c46-39093d6d1dd6" class="">In the mid-1950s, computers were still room-sized execution machines to be fed on a singular diet of punch cards. Human operators broke down a problem into tasks and fed them into the machine in the precise way that the machines understood, and the computer would perform the desired operation.</p><p id="a544b081-2394-443b-87e8-21973b59ba8f" class="">Even later, with the advent of computers as personal terminals, the singular gateway to interface with the machine was still by typing specific commands in the terminal, that executed those commands to open up the vast underbellies of specific programs. The needle moved from punch cards and 0s and 1s to a layer above in abstractions. But the way we interface with machines is still far way off from how we interface with humans.</p><p id="842f7519-ae09-41bb-a16c-0a7be7d9b74b" class="">
</p><p id="618e600b-6922-4a87-8062-063c88460f56" class=""><a href="https://en.wikipedia.org/wiki/Alan_Turing">Alan Turing</a>¬†was once having arguments with his colleagues and critics over whether a machine could ever have human-level intelligence.</p><p id="28094e41-41e3-4cb5-8d77-5e1b070455f0" class="">To prove his point, Turing proposed a game. In the game, an interrogator would ask questions to a human and a computer through a text-only chat interface. If the interrogator doesn&#x27;t find any difference between both their responses and the computer can successfully project itself as a real human then it passes the test. Turing called it ‚éØ¬†<code><em>the imitation game</em></code>.</p><p id="2b3bc0e4-f8a6-4e19-a0c8-865646a63a10" class="">Thereafter, between 1964 and 1967, Joseph Weizenbaum developed an early natural language processing computer program called ELIZA. Created to explore communication between humans and machines, ELIZA simulated conversation by using a¬†pattern matching¬†and substitution¬†methodology¬†that gave users an illusion of¬†<a href="https://en.wikipedia.org/wiki/Natural-language_understanding">understanding</a>¬†on the part of the program, but had no representation that could be considered ‚Äúunderstanding‚Äù what was being said by either party. The ELIZA program itself was originally written¬†in¬†<a href="https://en.wikipedia.org/wiki/SLIP_(programming_language)">MAD-SLIP</a>, the pattern matching directives that contained most of its language capability were provided in separate &quot;scripts&quot;, represented in a¬†<a href="https://en.wikipedia.org/wiki/S-expression">lisp-like representation</a>. The most famous script, DOCTOR, simulated a¬†psychotherapist of the Rogerian school¬†(in which the therapist often reflects back the patient&#x27;s words to the patient) and used rules, dictated in the script, to respond with non-directional questions to user inputs.<br/>But methods notwithstanding, ELIZA was one of the first computer programs (early chatbot) that could attempt Turing‚Äôs <br/><em>imitation game</em>.</p><figure id="5613e8b8-995a-4b74-9566-156c3256ac40" class="image"><a href="Reading%20between%20the%20lines%2067795472d8354f5b8834c65c0c98c646/Untitled.png"><img src="Reading%20between%20the%20lines%2067795472d8354f5b8834c65c0c98c646/Untitled.png"/></a><figcaption>Joy is a chatbot I wrote in early 2013 ‚éØ modelled after ELIZA with a kinda cheeky sense of humour. You can find the project <a href="https://github.com/GeekBoySupreme/joy">here</a> ‚ÜóÔ∏è</figcaption></figure><p id="c19434d9-1ef5-4c5e-bd50-6dafaf5dd32e" class="">While ELIZA was eligible to appear for Turing‚Äôs imitation game (later formalized in computational sciences as the <em>Turing Test</em>), it functioned with a very basic technology underneath.<br/><br/>Essentially, you type a sentence, the program breaks it down and looks for keywords in that sentence ‚éØ and then it passes the keywords through pre-programmed modifiers and response templates, resulting in a human-like response.<br/></p><figure id="e8bf03ab-acde-462b-b4c9-42ff75ce3243" class="image"><a href="Reading%20between%20the%20lines%2067795472d8354f5b8834c65c0c98c646/Untitled%201.png"><img style="width:2878px" src="Reading%20between%20the%20lines%2067795472d8354f5b8834c65c0c98c646/Untitled%201.png"/></a></figure><p id="0df81f1d-043b-4fe5-bb08-86ed3b27a19f" class="">Sometimes, when it does not understand what the user is saying, it simply repeats their words back to them.</p><figure id="a52f5b26-0dc8-48ff-b2e9-5bf77b99c5be" class="image"><a href="Reading%20between%20the%20lines%2067795472d8354f5b8834c65c0c98c646/Untitled%202.png"><img style="width:2026px" src="Reading%20between%20the%20lines%2067795472d8354f5b8834c65c0c98c646/Untitled%202.png"/></a><figcaption>A snippet of the exchange with ELIZA that Weizenbaum included in his original paper.</figcaption></figure><p id="136fdf58-0afd-4389-8455-00357ea87159" class="">
</p><p id="0961737c-610b-422d-bc26-da784a32dc55" class="">Inspired by ELIZA, in 1995, Richar Wallace composed ALICE ‚éØ which was another significant milestone in interacting with computers with natural language.<br/>ALICE was created to be a friendly entity on the internet that sought to be a friend you can talk to. It was one of the strongest programs of its kind and won the¬†<br/><a href="https://en.wikipedia.org/wiki/Loebner_Prize">Loebner Prize</a>, awarded to accomplished humanoids. ALICE, however, was unable to pass the¬†Turing test, as even the casual user will often expose its mechanistic aspects in short conversations.</p><figure id="6c84c92a-81b4-49b9-b2c6-837705bd5676" class="image"><a href="Reading%20between%20the%20lines%2067795472d8354f5b8834c65c0c98c646/Untitled%203.png"><img style="width:3024px" src="Reading%20between%20the%20lines%2067795472d8354f5b8834c65c0c98c646/Untitled%203.png"/></a><figcaption>ALICE‚Äôs code is open source and available in Google‚Äôs code archive</figcaption></figure><p id="028aa594-fc13-4680-b7e6-9ef5685cd7ab" class="">It is necessary to mention ALICE as it served 2 key functions, besides being a big push for chatbots to go mainstream -</p><ul id="50531e44-029b-401b-ab0d-87693a9ed932" class="bulleted-list"><li style="list-style-type:disc">It inspired Adam Spiegel (or Spike Jonze) to serve as the foundations for his 2013 Academy-award winning film - <a href="https://en.wikipedia.org/wiki/Her_(film)"><em>Her</em></a>, that went on to become a benchmark for how far we can push these algorithmic entities to be closer to human beings.</li></ul><ul id="aa404a47-37c1-4a34-96ac-37c4ae381022" class="bulleted-list"><li style="list-style-type:disc">The program uses an¬†<a href="https://en.wikipedia.org/wiki/XML_Schema_(W3C)">XML Schema</a>¬†called AIML (Artificial Intelligence Markup Language) for specifying the heuristic conversation rules ‚éØ and introduces the concept of using structured data to converse with a machine.</li></ul><p id="be9bce1b-5a45-4805-afd0-27f2183b69ea" class="">
</p><p id="bc1c8786-ed61-4798-84d1-f68b966abc93" class="">In the period between ELIZA‚Äôs rise and ALICE‚Äôs coming to life, there was another group of researchers at XEROX PARC working on something they christened <mark class="highlight-red"><em>GUS</em></mark> ‚éØ or <em>Genial Understander System. </em></p><p id="451cee52-5478-46fa-846f-80f2ebc72340" class="">The idea behind GUS was pretty straightforward - get things done on your computer by just talking naturally with a chatbot. GUS‚Äôs starting point was a travel agent with whom you could converse to book a flight to San Diego at the time of your choosing.</p><p id="e3fc1acb-729a-410d-bbfb-5dd225082542" class="">It is pretty simple use case to start with, but it was an important milestone as systems as they had been defined before worked strictly with specifically structured data, while natural language based systems are supposed to be more fluid and generalised. GUS was a big step in implementing interoperability of systems based on structured data to systems based on natural language.</p><figure id="b53dcd86-970b-460b-9f45-d9f70bf0ae49" class="image"><a href="Reading%20between%20the%20lines%2067795472d8354f5b8834c65c0c98c646/Untitled%204.png"><img style="width:2026px" src="Reading%20between%20the%20lines%2067795472d8354f5b8834c65c0c98c646/Untitled%204.png"/></a><figcaption>Learn more about GUS <a href="http://www.bitsavers.org/pdf/xerox/alto/Whole_ALTO_World_Newsletter_1977-1980.pdf">here</a> ‚ÜóÔ∏è</figcaption></figure><p id="19e19c44-8bb7-4307-a8bf-a9c823a8fd54" class="">Umpteen thinkers and computer scientists in the latter half of 1900s were tinkering with ideas on how can computers augment human intellect. In his seminal 1962 essay ‚éØ <a href="https://www.dougengelbart.org/pubs/papers/scanned/Doug_Engelbart-AugmentingHumanIntellect.pdf"><mark class="highlight-default"><em>Augmenting Human Intellect : A Conceptual Framework</em></mark></a><mark class="highlight-default"><em>, </em></mark><mark class="highlight-default">Douglas Engelbart mentions enhancing the capacity of comprehension to grasp complex problems and offer speedier resolutions as the end goal of where we want computers to go. <br/>Engelbart was not alone in this thinking, and inspired other scientists like Alan Kay to study how computers could amplify and perhaps help articulate the human imagination. While these early manifestations of tools unlocked pioneering ideas on the relationship between humans and machines, they were largely conceptual. Engelbart and Kay‚Äôs work hinted at a future of creative tools built to enhance the human mind‚Äôs creativity and intellect, but the translation of these ideas to tangible artefacts came along much later, in different forms.<br/></mark></p><p id="cff06e42-46a1-4d8e-997c-0f15f695f414" class="">In a 1945 essay titled <a href="https://worrydream.com/refs/Bush_1945_-_As_We_May_Think_(Life_Magazine).pdf"><mark class="highlight-default"><em>As we may think</em></mark></a>, Vannevar Bush coined the term &quot;<a href="https://en.wikipedia.org/wiki/Memex">memex</a>&quot;. Bush&#x27;s memex was based on what was thought, at the time, to be advanced technology of the future: ultra high resolution¬†microfilm¬†reels, coupled to multiple screen viewers and cameras, by electromechanical controls. The memex, in essence, reflects a library of collective knowledge stored in a piece of machinery described in his essay as &quot;a piece of furniture&quot;.<br/>The essay predicted (to some extent) umpteen different kinds of technology invented after its publication, including¬†hypertext,¬†personal computers, the¬†Internet, the¬†World Wide Web,¬†speech recognition, and¬†online encyclopaedias¬†such as¬†Wikipedia ‚éØ &quot;Wholly new forms of encyclopaedias will appear, ready-made with a mesh of associative trails running through them, ready to be dropped into the memex and there amplified.&quot; Bush envisioned the ability to retrieve several articles or pictures on one screen, with the possibility of writing comments that could be stored and recalled together. He believed people would create links between related articles, thus mapping the thought process and path of each user and saving it for others to experience. Wikipedia is one example of how this vision has, in part, been realised, allowing elements of an article to reference other related topics. A user&#x27;s browser history maps the trails of possible paths of interaction, although this is typically available only to the user that created it.<br/></p><p id="4f1ed4d7-56ec-431d-b41b-4f5d21a03551" class="">
</p><h2 id="b28d2cd4-919c-45e6-b523-6cc108d4c517" class="">Modern tools</h2><hr id="b33fa335-bd65-45a4-aa84-844aee041bc8"/><p id="bd0e094f-84da-4629-8025-a4ad2f313e24" class="">In the early 2000s, we came across SmarterChild ‚éØ an intelligent agent or ‚Äúbot‚Äù created by ActiveBuddy that could do a whole lot of things.<br/>The concept for conversational instant messaging bots came from the founder&#x27;s vision to add natural language comprehension functionality to the increasingly popular AOL instant messaging application. The original implementation took shape as a demo that Timothy Kay (founder of ActiveBuddy) programmed in¬†Perl¬†in his Los Altos garage to connect a single buddy ‚éØ &quot;ActiveBuddy&quot;, to look up stock symbols, and later allow AOL users to play¬†Colossal Cave Adventure, a famous word-based adventure game, and MIT&#x27;s Boris Katz Start Question Answering System but quickly grew to include a wide range of database applications the company called &#x27;knowledge domains&#x27; including instant access to news, weather, stock information, movie times, yellow pages listings, and detailed sports data, as well as a variety of tools (a personal assistant, calculator, translator, etc.)<br/></p><figure id="379196bf-ce3e-489b-9b67-d8e3527f9200" class="image"><a href="Reading%20between%20the%20lines%2067795472d8354f5b8834c65c0c98c646/Untitled%205.png"><img style="width:2026px" src="Reading%20between%20the%20lines%2067795472d8354f5b8834c65c0c98c646/Untitled%205.png"/></a></figure><p id="f0416495-d8f3-4954-8ec2-241bc32f55a1" class="">Services like SmarterChild and Wolfram Alpha (and it‚Äôs elder sibling ‚éØ Wolfram Mathematica) were essentially precursors to modern day Siri and Google Assistant. In fact, Shawn Carolan of Menlo Ventures, an investor in Siri , once said, &quot;‚Ä¶when I first encountered Siri, SmarterChild already had ten million users and was getting a billion messages a day‚Ä¶ The market was speaking.&quot;</p><p id="10d7c925-a42d-4ef4-b184-5b0cd6a65155" class="">Half a decade after Siri‚Äôs initial release, Facebook (now Meta) released M, it‚Äôs own personal assistant, and a whole new ecosystem to build bots on <a href="https://www.theverge.com/2016/4/12/11395806/facebook-messenger-bot-platform-announced-f8-conference">Facebook Messenger</a>. While the fundamentals remained the same, companies kept building tools to make it easier to extract intents from statements. Early tools like Google‚Äôs API.ai (later christened Dialogflow) let users program custom events and actions tied to inputs, but the key issue in machine learning systems remained, having access to enough data to convince the machine that ‚ÄúI want to hear the Eagles‚Äù still meant you want to listen to Hotel California and not <a href="https://youtu.be/9RArGl2vkGI?si=kFdYW9dqPat6AqUS">this</a>.</p><p id="fe1ca0d1-6a2a-4071-8df8-490b57e17fda" class="">
</p><p id="a0601847-f052-4699-a7e5-7084083aadc0" class="">The advent of Large Language Models does alleviate the resource conflict we used to face earlier while building systems that can extract intents from a wide array of possible input statements. But in the absence of an ability to interface with deterministic systems that are built to understand and work with structured data, we still have a chasm to cross.</p><p id="d04ff76d-279a-42c6-9272-777184bd4b21" class="">In spite of the technology industry‚Äôs investments in recreating human intelligence, the computer‚Äôs capacity to be fulfill a task is still entirely dependent on the operator‚Äôs ability to program that prescriptive creativity step-by-step into a machine. As Tony McCaffrey of¬†<a href="https://hbr.org/2017/04/there-will-always-be-limits-to-how-creative-a-computer-can-be"><em>There Will Always Be Limits to How Creative a Computer Can Be</em></a>¬†states, ‚ÄúThe fastest modern supercomputer couldn‚Äôt list or explore all the features of an object/thing even if it had started working on the problem way back in the 1950s. When considering the¬†<a href="https://www.tandfonline.com/doi/abs/10.1080/21650349.2014.893840?journalCode=tdci20">Obscure Features Hypothesis for Innovation</a>, which states that every innovative solution is built upon at least one new or commonly overlooked feature of a problem, you can see how AI may never advance enough to take the jobs of Chief Innovation Officers.‚Äù <br/><br/>While there are situations in which computers are able to figure out the steps needed to get from state A to a different state B, it is still within the limitations of human-mandated decomposition. This means that the actions we take with computers are steps that we have already broken down in our head in order to achieve an end result. <br/></p><p id="c039f310-7441-4a79-98b8-1bef9e6e94a5" class="">
</p><h2 id="40985bba-1048-4776-854b-0c1d7164a5d1" class="">Doneth</h2><hr id="139d710d-050c-41eb-a831-fbf9f5cd4e7d"/><p id="b6ad654c-0b7e-4267-a08f-f0253b6718af" class="">We looked around to find use cases for a possible proof of concept of using LLMs as a form of general purpose classifier to extract intents from statements with minimal pre-training. We looked for what we do often that can be easily automated, accelerated, or enhanced with GPT-3. We initially gunned to build an intelligent omnibox, a fusion of Siri and Spotlight, powered by GPT-3. We discarded the idea because the omnibox would not be very useful without an array of key integrations. <br/>For eg - If I write <br/><code>Schedule a meeting with Alex Ohanian tomorrow at 6:30pm PT</code> in my Omnibox, I would expect the Omnibox to have Calendar and Zoom integrations ready to fire and set things up for me. If that were possible, we would have possibly been building the next Zapier, powered by GPT-3. But this is a tall ask, considering building Integrations is a tall task. We fell back to something far more prevalent and obvious.</p><p id="888602d5-a68b-40d8-83b5-f96315fd7620" class="">
</p><p id="9e2f2fac-121f-4902-81bd-df4f3e213234" class=""><mark class="highlight-red">A to-do app.</mark></p><p id="be695060-0e76-4ce8-9253-7f2dd6b5c667" class="">
</p><p id="a70ec54a-dba1-45d9-88f7-ffd517ca6b38" class="">Obviously, a to-do app is as simple as it gets to building a project. In fact, it is the Hello World for anyone getting started with building for the web, iOS, or Android. We wanted to transform this simple to-do app into something far more powerful.</p><p id="ecaa2a27-3529-41d6-b017-c5e9cfe959f4" class="">
</p><h3 id="e53cc2b8-8fa2-4e03-956f-3317dd8dc027" class=""><strong>Why a to-do app?</strong></h3><p id="8982ff82-b449-48be-9bc2-17dd01db38e4" class="">To-do apps are one of the highest used apps/services across the world. Notion was initially built to be a to-do app before the creators expanded its feature set. You have the Big 3 - Google, Microsoft, and Apple, all running to build the next best to-do app. There are independent companies ‚éØ Evernote, and Todoist : million-dollar businesses that try and help users get things done. <br/>The question is, do they actually help you get things actually &quot;done&quot; though? Or just add an additional cognitive load by reminding the user that they still have a load of things to do.<br/></p><p id="b15f4744-bb87-4b87-a807-f4ae2605ca5e" class="">
</p><p id="584d5a49-b53f-409b-a65c-f54da997fef6" class="">With <strong>Doneth</strong>, we are trying to change that. We have started small, nothing too big or out of the world yet. But we want to build meaningful interactions for the most common and obvious tasks, right inside your to-do list. We want the user to not - open their to-do list ‚Üí exit and open the relevant app ‚Üí do something / check for a movie / find a recipe ‚Üí repeat. <br/>To break this cycle, we are bringing intent-driven actions right inside your to-do list.<br/></p><p id="eb67c263-6c0b-48fc-8ceb-52450f2629f9" class="">
</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="448174a3-01a6-4aa0-80b1-1ae3aa0f533b"><div style="font-size:1.5em"><span class="icon">üöß</span></div><div style="width:100%">This project is an advancement on some of my earlier work from 2019 on rendering dynamic interfaces using machine learning. You can take a look at the <a href="https://github.com/GeekBoySupreme/talks/blob/master/Building%20UX%20with%20ML%20%23DevFestBlr.pdf">slides here</a> ‚ÜóÔ∏è</div></figure><p id="92bc0d79-39bd-40a9-98ae-b1c42ba0cde5" class="">
</p><p id="3cc4a9e1-e4a7-495e-8123-f3ade4bdb821" class="">With Doneth, we have identified some of the most common tasks that users list on their to-do list and have added microapps right inside Doneth so that they can check what they need to do without having to leave their list and go somewhere else. The idea is simple enough - you add a task, and Doneth figures out which microapp would you potentially need to fulfill the said task. You click on the microapp button that pops up right below your task and the window to fulfill your task comes up. Now, there is a huge ocean of things we can do here. Powered by GPT-3, Doneth is pretty accurate as to figure out the intent and extract the necessary entities from a natural language statement. The caveat? We have not been able to build a whole arsenal of microapps that we would have loved to integrate. We have a handful of them ready to go, and we would cover more on them, and how they work in due course of this article.<br/><br/></p><p id="98e4f675-0b4e-4b01-ad18-6fcc2eaa7116" class="">Here‚Äôs a preview of how Doneth works üëá</p><figure id="de1cf4d8-fa92-4be8-8a4b-fb08e8d544dd">
	<div class="source"><video width="100%" controls>
		<source src="Reading%20between%20the%20lines%2067795472d8354f5b8834c65c0c98c646/Untitled.mp4" type="video/mp4">
	  Your browser does not support the video tag.
	  </video></div></figure><p id="a5552bcc-9db7-47aa-8bc7-6f385be73f7f" class="">The user opens the webpage (the current implementation of Doneth is just on the Web) and encounters a text field, an add button, and a list of tasks. No frills or features to sidetrack you from what you came on to do ‚éØ to add your task, and at some point, get it done.</p><p id="20581368-418f-4a95-b348-e84d45fa3b45" class="">
</p><p id="ba7688e4-6215-4c5f-978c-3b8761edadf2" class="">Once you add your task, it takes some time for your task to get added to the Task list (reason - GPT-3 APIs are excruciatingly slow), but when it does, it has a small button that let&#x27;s you do, or rather, makes it easier to do, what the user has mentioned that they need to get done.</p><p id="5e1f0f10-f7d2-4303-813c-f8b5614ce4f2" class="">Now, since this project was built with the intention to showcase and experiment with GPT-3, the user might not find every single feature they would associate with a to-do app because of course, our priorities were slightly different. We prioritised adding a bunch of microapps over priority labels, but we promise it&#x27;s all for the greater good. If Doneth does go to market someday, it would sure sport the regular features that grace other to-do apps.</p><p id="b62584ea-0f11-4d78-91df-502fe18435b3" class="">
</p><p id="94fe96ea-ad35-4dd3-bbf0-db17f2cf6bf9" class=""><strong>Micro-apps</strong></p><p id="8f6de811-bf22-444f-938f-abf4de7028ef" class="">With all focus on these smaller integrations, what did we end up integrating to Doneth in the first place?</p><p id="9577051d-76af-4e72-9db2-7a6b0e1fabcd" class="">v0.2.0, as of the time of writing this report, Doneth has 7 live text-based integrations - </p><ul id="f94f89b1-7464-40ec-9b43-9c449b4457d2" class="bulleted-list"><li style="list-style-type:disc">Find a movie (or TV Series) to watch</li></ul><ul id="15408eaa-caf4-4912-b3b2-bb8e29975b2c" class="bulleted-list"><li style="list-style-type:disc">Find something to eat (shows you a recipe)</li></ul><ul id="9328ff19-d802-4a3d-b008-777cef2b8f91" class="bulleted-list"><li style="list-style-type:disc">Write an essay (helps you expand and write on a topic)</li></ul><ul id="f9f3a28c-e00d-4924-bc72-6d8a3abb1aae" class="bulleted-list"><li style="list-style-type:disc">Summarize (helps you summarize something)</li></ul><ul id="4e1e681e-009d-40f9-80f3-06f835a7cedf" class="bulleted-list"><li style="list-style-type:disc">Open a Map or help you call a cab</li></ul><ul id="ccbb8249-c4ce-4251-b5d0-ba04ff1df966" class="bulleted-list"><li style="list-style-type:disc">Play Music</li></ul><ul id="4d1f0f40-b577-46ea-a39b-78a837558054" class="bulleted-list"><li style="list-style-type:disc">Find/generate Study Notes</li></ul><p id="4285dfce-245a-4a49-be39-fa1a9ddd6455" class="">Key point to note is that many of these integrations in turn, are also powered by GPT-3.<br/>But before we dive into what these integrations do and how they do it, we would take a look at GPT-3, the white paper behind it, and how the API comes together in creating Doneth.<br/><br/><br/></p><h2 id="a9de8428-e8dd-42fb-91cf-46c05c6ffd20" class="">GPT-3</h2><hr id="0c55cede-f6e6-40c0-bf37-7dc055569c5f"/><p id="6cb2297c-e969-47e7-847e-acc730e311e7" class=""><strong>tl;dr</strong></p><p id="04dd0ea9-cf61-4c58-ade8-b54a914b3005" class="">GPT-3 is OpenAI&#x27;s latest language model. It incrementally builds on model architectures designed in previous research studies, but its key advance is that it&#x27;s extremely good at &quot;few-shot&quot; learning. There is a lot it can do, but one of the biggest pain points is in &quot;priming,&quot; or seeding, the model with some inputs such that the model can intelligently create new outputs. Many people have ideas for GPT-3 but struggle to make them work, since priming is a new paradigm of machine learning.</p><p id="5ea0ad2e-c89e-432d-beba-7f577b2d6b10" class="">
</p><p id="63282404-620b-421a-8618-9dc4d8db3a8e" class=""><strong>Not tl;dr</strong></p><p id="548bd3b2-134a-4041-834d-88b8a13a8e64" class="">Recent years have featured a trend towards pre-trained language representations in NLP systems, applied in increasingly flexible and task-agnostic ways for downstream transfer. First, single-layer representations were learned using word vectors and fed to task-specific architectures, then RNNs with multiple layers of representations and contextual state were used to form stronger representations (though still applied to task-specific architectures), and more recently pre-trained recurrent or transformer language models have been directly fine-tuned, entirely removing the need for task-specific architectures.</p><p id="6074c05b-9be9-47ed-ad5a-73dd20528ca5" class="">This last paradigm has led to substantial progress on numerous challenging NLP tasks - such as reading comprehension, answering questions, textual entailment, and many others, and has continued to advance based on new architectures and algorithms. However, a major limitation to this approach is that while the architecture is task-agnostic, there is still a need for task-specific datasets and task-specific fine-tuning: to achieve strong performance on a desired task typically requires fine-tuning on a dataset of thousands to hundreds of thousands of examples specific to that task. Removing this limitation would be desirable, for several reasons -<br/><br/></p><ul id="6f071fe0-83e4-402e-b2dd-ac0a9f9f1c40" class="bulleted-list"><li style="list-style-type:disc">First, from a practical perspective, the need for a large dataset of labeled examples for every new task limits the applicability of language models. There exists an extremely wide range of possible useful language tasks, encompassing anything from correcting grammar to generating examples of an abstract concept, to critiquing a short story. For many of these tasks, it is difficult to collect a large supervised training dataset, especially when the process must be repeated for every new task.<br/><br/></li></ul><ul id="600d2634-c7b6-41a0-8cbc-10b5f206d487" class="bulleted-list"><li style="list-style-type:disc">Second, the potential to exploit spurious correlations in training data fundamentally grows with the expressiveness of the model and the narrowness of the training distribution. This can create problems for the pre-training plus fine-tuning paradigm, where models are designed to be large to absorb information during pre-training but are then fine-tuned on very narrow task distributions.<br/><br/></li></ul><ul id="71caa33e-9b0d-4f90-8d37-4bd1b186cb04" class="bulleted-list"><li style="list-style-type:disc">Third, humans do not require large supervised datasets to learn most language tasks ‚Äì a brief directive in natural language (e.g. ‚ÄúPlease tell me if this sentence describes something happy or something sad‚Äù) or at most a tiny number of demonstrations (e.g. ‚Äúhere are two examples of people acting brave; please give a third example of bravery‚Äù) is often sufficient.</li></ul><p id="a56645dc-68b3-41c4-9ad6-b99c9e374d11" class="">
</p><p id="c6252cc9-6766-4789-b112-64b41883378d" class="">One of the ways to solve this issue might be through &quot;meta-learning&quot;, which in the context of language models means the model develops a broad set of skills and pattern recognition abilities at training time and then uses those abilities at inference time to rapidly adapt to or recognize the desired task.</p><p id="f3210712-c290-496a-ac4d-ef34eecc2a17" class="">The original GPT-3 white paper, explores some of these methods and decides to go ahead with another trend in the NLPverse - increasing parameters to a transformer model. </p><p id="b7d3800f-e50c-450f-84ec-1f7300802f73" class="">To quote the authors -</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="183780d0-35c1-4e76-bb39-ba88fdf7b747"><div style="font-size:1.5em"><span class="icon">üöß</span></div><div style="width:100%">In recent years the capacity of transformer language models has increased substantially, from 100 million parameters [RNSS18], to 300 million parameters [DCLT18], to 1.5 billion parameters [RWC+19], to 8 billion parameters [SPP+19], 11 billion parameters [RSR+19], and finally 17 billion parameters [Tur20]. Each increase has brought improvements in text synthesis and/or downstream NLP tasks, and there is evidence suggesting that log loss, which correlates well with many downstream tasks, follows a smooth trend of improvement with scale [KMH+20]. Since in-context learning involves absorbing many skills and tasks within the parameters of the model, it is plausible that in-context learning abilities might show similarly strong gains with scale.</div></figure><p id="8d67d913-edf7-4e9b-beab-4d894ecee733" class="">
</p><p id="b0eb7150-f5be-419f-9227-bd6936163adc" class="">In the paper, the hypothesis is tested by training a 175 billion parameter autoregressive language model, and measuring its in-context learning abilities. Specifically, the authors evaluated GPT-3 on over two dozen NLP datasets, as well as several novel tasks designed to test rapid adaptation to tasks unlikely to be directly contained in the training set.<br/><br/>GPT-3 was evaluated under 3 conditions - <br/></p><ul id="a0dd88ca-023f-4906-adee-1dd18fb72aea" class="bulleted-list"><li style="list-style-type:disc">‚Äúfew-shot learning‚Äù, or in-context learning where the authors allowed as many demonstrations as will fit into the model‚Äôs context window (typically 10 to 100),</li></ul><ul id="8652651a-d978-44f0-9275-07f3b88b8c4c" class="bulleted-list"><li style="list-style-type:disc">‚Äúone-shot learning‚Äù, where only one demonstration is allowed, and</li></ul><ul id="afbf1901-2e6a-4dcc-a9f2-6f8c75197a4d" class="bulleted-list"><li style="list-style-type:disc">‚Äúzero-shot‚Äù learning, where no demonstrations are allowed and only an instruction in natural language is given to the model.</li></ul><p id="b43fea6b-da98-4d4e-afbb-cef5e12e5796" class="">
</p><p id="386917f4-89a1-465c-a2c9-77449947a213" class=""><strong>Results</strong></p><p id="c1f1b9b5-80bd-4ee0-9261-f62e2f3894f4" class="">Broadly, on NLP tasks GPT-3 achieves promising results in the zero-shot and one-shot settings, and in the few-shot setting is sometimes competitive with or even occasionally surpasses state-of-the-art (despite state-of-the-art being held by fine-tuned models). For example, GPT-3 achieves 81.5 F1 on CoQA in the zero-shot setting, 84.0 F1 on CoQA in the one-shot setting, and 85.0 F1 in the few-shot setting. Similarly, GPT-3 achieves 64.3% accuracy on TriviaQA in the zero-shot setting, 68.0% in the one-shot setting, and 71.2% in the few-shot setting, the last of which is state-of-the-art relative to fine-tuned models operating in the same closed-book setting.</p><p id="089b09e8-64ef-49a6-9093-2279f6434a75" class="">
</p><p id="f8169b54-f162-4f26-a276-e12ff2239d69" class="">To know more about GPT-3 and how the authors achieved these results, here is the original paper - <a href="https://arxiv.org/pdf/2005.14165.pdf">https://arxiv.org/pdf/2005.14165.pdf</a></p><p id="601111eb-863b-4766-949a-f28462296c2b" class="">
</p><h2 id="47e622ab-fee6-408d-b7ec-c667d5a02245" class="">OpenAI API</h2><hr id="70d1444e-45f4-4a9b-92c2-183f37a23df2"/><figure id="e06868f0-6a71-49fd-bf31-abe16bdf852e" class="image"><a href="Reading%20between%20the%20lines%2067795472d8354f5b8834c65c0c98c646/Untitled%206.png"><img style="width:877px" src="Reading%20between%20the%20lines%2067795472d8354f5b8834c65c0c98c646/Untitled%206.png"/></a></figure><p id="515466fe-0fd9-4e64-8615-c1f567f60a46" class="">GPT-3 the model and its details were not released to the general audience.<br/>But on June 11, 2020 - OpenAI exposed the model in the form of a restricted API for beta users. <br/></p><p id="aa5751f2-8807-4b18-9c7f-78f831483eea" class="">
</p><p id="11dc77eb-0be1-4841-9463-c3a698a59750" class="">Given any text prompt, the API will return a text completion, attempting to match the pattern the user gives it. We can ‚Äúprogram‚Äù it by showing it just a few examples of what you‚Äôd like it to do (few-shot learning); its success generally varies depending on how complex the task is. The API also allows us to hone performance on specific tasks by training on a dataset (small or large) of examples we provide, or by learning from human feedback provided by users or¬†labelers.</p><p id="4180578c-7216-4075-83e9-ab1fe58e7afd" class="">Microsoft is one of the biggest names to license GPT-3 to improve its low-code offering - the Power FX programming language available in MS Excel, to better detect syntax errors, and parametric anomalies, and fix them on the fly for the user (a GPT-3 powered autocorrect is a suitable analogy).<br/>Recently, another of GitHub&#x27;s bigger acquisitions - GitHub released the <br/><strong>Copilot</strong>, a code-completion extension for VS Code similar to what Smart Replies does for Gmail - augments the user by predicting what the next snippet of code should be.</p><p id="811b7053-0713-4a89-8418-432bafce36b5" class="">
</p><p id="80e96f60-869d-484b-8947-420313cf362c" class="">
</p><p id="4a359e06-c07a-4128-a496-65bbe13191e9" class=""><strong>How does it work?</strong></p><p id="6fdad63b-b711-4793-9fce-e78321f8978e" class="">Let&#x27;s take a look at what the API Request looks like - </p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="ea22774b-a07e-42eb-af6f-aefa3e0c4139"><div style="font-size:1.5em"><span class="icon">üìé</span></div><div style="width:100%">curl <a href="https://api.openai.com/v1/engines/davinci/completions">https://api.openai.com/v1/engines/davinci/completions</a> \<br/>-H &quot;Content-Type: application/json&quot; \<br/>-H &quot;Authorization: Bearer $OPENAI_API_KEY&quot; \<br/>-d &#x27;{<br/>&quot;prompt&quot;: &quot;$PROMPT_TEXT&quot;,<br/>&quot;temperature&quot;: 0.5,<br/>&quot;max_tokens&quot;: 100,<br/>&quot;top_p&quot;: 1,<br/>&quot;frequency_penalty&quot;: 0.2,<br/>&quot;presence_penalty&quot;: 0,<br/>&quot;stop&quot;: [&quot;\n&quot;]<br/>}&#x27;<br/></div></figure><p id="0b7ac65c-5cac-40ba-a308-6eae1a16fab0" class="">
</p><p id="ca8d2540-f352-4ce4-9ad9-0eee159e8dfc" class=""><strong>Prompt</strong></p><p id="e91af85d-ee5c-447f-ae7c-61fbaf544bb4" class="">The prompt is a selection of curated Inputs and Outputs that we feed into GPT-3 to ensure that it gives us an output in accordance with a pre-defined pattern. We mentioned few-shot learning earlier, and with the prompt that is what we try to do, instead of simply relying on GPT-3 to give a random output.<br/>A prompt is far smaller than any traditional dataset. But the way GPT-3 has been trained for multiple use cases, a few-shot learning paradigm makes it easier for us to re-orient the model to give outputs in a pre-defined pattern.<br/></p><p id="11c8d8fd-4577-4c55-8809-fec26eb51b69" class="">
</p><p id="c8853962-e5bd-481c-bcfd-841d87bdc4ab" class=""><strong>Temperature</strong></p><p id="264c8c2d-67a6-4987-9f24-085505b51ca5" class="">One of the most important settings to control the output of the GPT-3 engine is the temperature. This setting controls the randomness of the generated text. A value of 0 makes the engine deterministic, which means that it will always generate the same output for a given input text. A value of 1 makes the engine take the most risks and use a lot of creativity.</p><p id="d8ab49b9-b3fc-4a4c-b9bc-ec0b3296b0c2" class="">
</p><p id="ba4974ed-f6e0-476f-be5b-5ff3a8446523" class=""><strong>Max Tokens</strong></p><p id="4a7c1103-6821-41f1-974d-18f14b84511c" class="">Denotes the number of tokens that would be used in the output sequence text.<br/>The default setting for response length is 64, which means that GPT-3 will add 64 tokens to the text, with a token being defined as a word or a punctuation mark.<br/></p><p id="8203edc6-e51c-42f9-9b22-7eb41e507e78" class="">
</p><p id="be639481-e572-497c-8b18-8340a8e00e65" class=""><strong>Top P</strong></p><p id="efc64d0f-dc90-49df-962a-066de9b86da6" class="">The ‚ÄúTop P‚Äù parameter also has some control over the randomness of the response.</p><p id="f33abd8e-40ce-45b2-a192-4e90159706c0" class="">
</p><p id="17d83ea0-0691-4cdc-a26f-fd27465af898" class=""><strong>Frequency and Presence Penalty</strong></p><p id="bbff3aa4-7dc4-4d0b-9a4e-466f3ac91d21" class="">Frequency penalty works by lowering the chances of a word being selected again the more times that word has already been used. The presence penalty does not consider how frequently a word has been used, but just if the word exists in the text.</p><p id="a3e556f6-9b42-4d5c-a4b3-f8014c245bcc" class="">The difference between these two options is subtle, but you can think of the Frequency Penalty as a way to prevent word repetitions, and the Presence Penalty as a way to prevent topic repetitions.</p><p id="e5e7aa42-be80-4efc-9c82-61e209e262cb" class="">
</p><p id="6b708596-d391-42df-9914-e444ee7ce05a" class=""><strong>Stop sequence</strong></p><p id="224674c2-4fc0-48e5-a9ea-b895afd8e029" class="">The ‚ÄúStop Sequences‚Äù option allows us to define one or more sequences that when generated forces GPT-3 to stop.</p><p id="e4ab5144-7659-462a-b7a9-f7cb448d7eb2" class="">
</p><p id="69b5ac6c-7044-4dc3-b860-dc764f66d285" class="">
</p><h3 id="2aca93d2-e1ec-48bb-b90e-2968b546e645" class=""><strong>Language Models</strong></h3><hr id="2f9b66fb-af5f-4d87-b1de-cda13e344953"/><p id="6dd140a5-65d3-4cf0-b001-8803d415bc29" class="">The OpenAI API comes with a few language models that we can use. In the API request above, they are called engines - </p><p id="490076b8-75da-47a5-b12a-9a25922a7350" class=""><code>v1/engines/davinci</code> - <code>davinci</code> is one of the predefined language models. There are a few more -</p><p id="e5586967-ab72-40fb-94dc-8728adde6146" class="">
</p><p id="36e6243d-9a9e-4e5c-9866-afa061cf2b2f" class=""><strong>Davinci</strong></p><p id="4b969a87-8035-4689-b967-58614a19e6f4" class="">Davinci is the most capable engine and can perform any task the other models can perform often with less instruction. For applications requiring a lot of understanding of the content, like summarization for a specific audience and creative content generation, Davinci is going to produce the best results. These increased capabilities require more computing resources, so Davinci costs more per API call and is not as fast as the other engines.</p><p id="625aafbd-3dec-4366-b7ed-dd5b2d5c8d70" class="">Another area where Davinci shines is in understanding the intent of the text. Davinci is quite good at solving many kinds of logic problems and explaining the motives of the characters. Davinci has been able to solve some of the most challenging AI problems involving cause and effect.<br/><br/>Good at:¬†<mark class="highlight-yellow_background">Complex intent, cause, and effect, summarization for audience.</mark></p><p id="ddc985bc-bb03-4449-b936-7e1d10dfadf8" class="">
</p><p id="13f3e913-1f6a-4666-8318-fc3be3904075" class=""><strong>Curie</strong></p><p id="fb91ea57-9252-4b4c-a485-188ad5482314" class="">Curie is extremely powerful, yet very fast. While Davinci is stronger when it comes to analyzing complicated text, Curie is quite capable for many nuanced tasks like sentiment classification, and summarization. Curie is also quite good at answering questions and performing Q&amp;A and as a general service chatbot.<br/><br/>Good at:¬†<mark class="highlight-yellow_background">Language translation, complex classification, text sentiment, summarization.</mark></p><p id="cf6d408d-f72e-490c-a73c-a5cdc270265a" class="">
</p><p id="1d041a9e-f0e6-45d2-ac43-2e0949c1bd21" class="">
</p><p id="74a47187-f53d-46e6-9e72-edbf963f0ba3" class=""><strong>Babbage</strong></p><p id="b0df9f56-13e6-4885-9669-ac9c44e28be1" class="">Babbage can perform straightforward tasks like simple classification. It‚Äôs also quite capable when it comes to Semantic Search ranking how well documents match up with search queries.<br/><br/>Good at:¬†<mark class="highlight-yellow_background">Moderate classification, semantic search classification.</mark></p><p id="3f80da25-660b-4094-b950-6d5e0d386c00" class="">
</p><p id="b806c3b8-e73b-4b11-871e-6b1874851213" class="">
</p><p id="d1d6d8ff-4bd6-4ed2-816f-7ab81575261e" class=""><strong>Ada</strong></p><p id="5d3a4d5b-5599-4164-b6e0-25c4779019b2" class="">Ada is usually the fastest model and can perform tasks like parsing text, address correction and certain kinds of classification tasks that don‚Äôt require too much nuance. Ada‚Äôs performance can often be improved by providing more context.<br/><br/>Good at:¬†<mark class="highlight-yellow_background">Parsing text, simple classification, address correction, keywords.</mark></p><p id="543ca5ab-ff78-4b7f-aacf-d296380468ab" class="">
</p><p id="a3656087-6774-4536-825b-cea87e7b6431" class="">
</p><h2 id="e71f99ec-6f33-4820-b279-6f37d24c49c3" class="">Intent extraction with GPT-3</h2><hr id="c1ef9794-8a83-4e00-88ee-c47ecb8a054d"/><p id="ba558b25-a9ff-48e0-873d-3027970f6118" class="">In the ideal scenario, a paradigm where Large Language Models can switch to a deterministic mode to send a response, we‚Äôd just pass the input statement and receive a structured response that we can work with further.</p><figure id="f0aae37b-a9bb-402a-b8c6-2a7e005f745e" class="image"><a href="Reading%20between%20the%20lines%2067795472d8354f5b8834c65c0c98c646/Untitled%207.png"><img style="width:2878px" src="Reading%20between%20the%20lines%2067795472d8354f5b8834c65c0c98c646/Untitled%207.png"/></a><figcaption>What we initially set out to achieve üëÜ</figcaption></figure><p id="a4321df3-25cc-4ad3-81a1-58ede01c6f9c" class="">A few tries in, it became clear that GPT-3 was bad at adhering to a specific format. And even if the format has been repeated in the context prompt, there were a lot of instances of hallucination where the LLM is dreaming up its own schema, and adding key-value pairs that have not been defined. <br/>Even the parameters of the JSON object that were added to the prompt were getting shuffled around or being re-worded. We cannot exactly listen for a field for <br/><code>intent</code> when GPT-3 in its response, transforms it to <code>intention</code>.</p><p id="d993a0dc-b234-4a16-b65c-02ce05d8a229" class="">
</p><p id="1a179e7b-9a48-471c-a8a0-51673aef18e9" class="">One important piece that sets apart this approach from regular classification is that we wanted to also extract arguments from the statement, not just the intent. In a to-do app, you don‚Äôt have the affordances to ask the user repeatedly to input arguments, so the entire context needs to be extracted from the get-go. <br/>For eg - Say I want a music player built right inside doneth. I have added a to-do : ‚ÄúPlay Indian Ocean on loop at night‚Äù. Now from this statement, I want the intent of the user, let‚Äôs call it <br/><code>play-music</code> and to the corresponding function that gets called for this intent, say <code>function play_music()</code>, I would also want to pass the band name as a parameter so that I can build a construct where the user clicks on the <code>Play Music</code> button, the program can automatically open Spotify with the artist‚Äôs page in front ‚éØ ready to play their songs.</p><figure id="a551d18c-0eca-439c-916c-ccf70a233e49" class="image"><a href="Reading%20between%20the%20lines%2067795472d8354f5b8834c65c0c98c646/Untitled%208.png"><img style="width:2878px" src="Reading%20between%20the%20lines%2067795472d8354f5b8834c65c0c98c646/Untitled%208.png"/></a></figure><p id="d9697841-6a1c-4084-901b-5351df8456c6" class="">When you get both the <code>intent</code> and the <code>argument(s)</code>, it affords a far easier picture for you to render dynamic interfaces on top of this ‚éØ and this can be extended into far more complex scenarios, converting the LLM into essentially a search engine in latent space. You can also think of a scenario where you can use the intent and arguments to launch other LLMs, like <code>Dall-E</code> to achieve more.</p><figure id="cb2c818d-f36d-4d0b-874d-8cf06de7d0eb" class="image"><a href="Reading%20between%20the%20lines%2067795472d8354f5b8834c65c0c98c646/Untitled%209.png"><img style="width:3300px" src="Reading%20between%20the%20lines%2067795472d8354f5b8834c65c0c98c646/Untitled%209.png"/></a></figure><p id="26a5d0ef-ed65-41cb-8f7d-a867d5c2220c" class="">The current state of LLMs being a black box can be solved to a certain extent by reducing a natural language input into its corresponding intent and arguments ‚éØ . This leads to a more powerful pattern of rendering full-fledged micro-apps inside the context of a conversation.<br/>Imagine wanting to play sudoku, and a sudoku game is rendered for you on the fly, or a relevant part of your calendar becomes visible when you are trying to resolve a scheduling conflict conversationally.<br/></p><p id="91f6e663-d26a-44e6-8098-c93776f7d2f6" class="">
</p><p id="4e58a824-ce51-4f91-a1fe-e6ff3e74a15d" class="">As JSON output is not readily available, we developed a formatting technique that the LLM can follow while answering. And since this formatting is derived from a simple string manipulation concept using delimiters, GPT-3 did not have much trouble generating consistent, parseable outputs. This is the formatting scheme we arrived at üëá</p><figure id="43b29636-e806-4246-adcf-f324e46f1ecc" class="image"><a href="Reading%20between%20the%20lines%2067795472d8354f5b8834c65c0c98c646/Untitled%2010.png"><img style="width:3710px" src="Reading%20between%20the%20lines%2067795472d8354f5b8834c65c0c98c646/Untitled%2010.png"/></a></figure><p id="83d61551-07d8-48b8-87cd-ff0c70c7e223" class="">Initially, when you‚Äôre writing a to-do, we send a prompt that allows us to parse any input text into a series of entities. The way we have structured the entities is that the first of the entity series denotes the intent, and the subsequent elements, reflect the multiple parameters that we can use while building integrations further down the line.</p><p id="2e542bdc-7cf1-4c15-8e1d-6930ccb90485" class="">
</p><p id="6d73a377-2a70-41e4-b689-a7e1caed661e" class="">Example Prompt - </p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="42d48661-a5fd-4c71-bad9-1e602f3797bf"><div style="font-size:1.5em"><span class="icon">üìé</span></div><div style="width:100%">Q: Book a cab for tomorrow to go to college<br/>A: book-cab / to college / tomorrow<br/><br/>Q: Play a song from Cactus<br/>A: play-song / cactus<br/></div></figure><p id="78d28436-098a-4e0b-b46f-ceaadafcb055" class="">where <strong>Q </strong>‚Üí Input prompt; <strong>A </strong>‚Üí Expected output</p><p id="43925834-f296-48b2-932d-79e0aaaafb66" class="">
</p><p id="e42eb2b0-7074-4928-8be9-9a646ed104e8" class="">The actual prompt consists of quite a few more sample input-output sets.<br/>Once we get the response, we run the split() function in Javascript and extract the intent and other parameter entities from the resultant array. Now we have ensured that we receive the data as a string, we can optimize the response to resemble a structured JSON from where we can simply extract the parameters, as they would surely increase the load as we move towards building more complex interactions.<br/></p><p id="c1b0d640-c426-4bdc-b1f6-1958b8bcba9e" class="">We also envision Doneth to not just be a tool, but a platform. Accordingly, we have structured the code to make it extremely easy to plug in new interactions and micro-apps. We do not have complete developer documentation for it at the moment - but that is another task on the roadmap.</p><p id="78e2e9cd-4084-45e9-a49e-ae506cdf7224" class="">
</p><h2 id="d1c984ce-8052-4df0-8cda-8736bb0b3a05" class="">Final thoughts</h2><hr id="29dc0101-2e67-448d-ab58-a37dca9a3b27"/><p id="41b3ac52-52fc-4458-b308-5e5771bdfdb8" class="">Acknowledging that LLMs are not inherently creative/structured should not come as a surprise. However, it does point to the fact that we can leverage them to create far more nuanced, and personalized actions that help the human operator in achieving their tasks in a superior, and more efficient way. This facilitates a whole new arena of interfaces that render dynamic bits on the fly as and when the user needs them ‚éØ this again caveats to the point of knowing which dynamic bit to render where. <br/>When OpenAI released its code generation model - <br/><code>Codex</code>, it raised expectations of the program knowing which bits of code to render, and in the future, it might lead to computers directly rendering a fresh component instead of just showing the code to render the said component.</p><p id="c3dcc9e9-96a5-4868-bde4-3d504c15d85b" class="">
</p><p id="747e9d4c-ae9a-4482-940e-dcc660703d81" class="">Understanding the restrictions of technologies like Large Language Models gives us a better shot at making computers assume the role of a co-creator in human endeavors instead of just being a number-crunching machine. Not as an idea-generator, but more of an <em>actualizer</em>.</p><p id="5f207eab-0de3-4aca-a266-f08c8152ad2b" class="">Imagine a paradigm a few years down the line when we have multiple companies releasing separate models that excel at one or two things. We might have a model that is exceptionally good with classifying intent and extracting arguments from an input statement, and we can leverage that to call other LLMs for the specified task ‚éØ imagine calling Dall-E or Midjourney to generate images, some other model to generate music, you can render a micro-app to help tune your instrument, solve a crossword, etc. Routing these function calls to use an appropriate LLM would also enable us to chain contexts and pass information extracted by one model to another. In the case of image generation, this would allow us to stack prompts the same way we stack layers on <a href="https://www.figma.com/">Figma</a>, and we would finally be able to fix hands.</p><p id="b54d1186-1854-481c-bef5-f67ee2ff486d" class="">The main essence distills down to having the autonomy to get an LLM to do what you want ‚éØ instead of the LLM doing whatever they want and you having to tweak things around in other tools using the output.</p><p id="a00c40e3-e5a4-45b7-9f70-5805832725a6" class="">
</p><p id="fd7cdd66-3805-48d0-9f6b-f4033259574a" class="">Steve Jobs once explained during an interview in¬†<a href="https://www.imdb.com/title/tt0419958/"><em>Memory &amp; Imagination: New Pathways to the Library of Congress</em></a><em>,</em>¬†‚ÄúThat‚Äôs what a computer is to me‚Ä¶ it‚Äôs the most remarkable tool that we‚Äôve ever come up with, and it‚Äôs the equivalent of a bicycle for our minds.‚Äù </p><figure id="da9710f2-3601-4b11-9803-532d4955e38e" class="image"><a href="Reading%20between%20the%20lines%2067795472d8354f5b8834c65c0c98c646/Untitled%2011.png"><img style="width:2026px" src="Reading%20between%20the%20lines%2067795472d8354f5b8834c65c0c98c646/Untitled%2011.png"/></a></figure><p id="808e671d-e5f2-42db-b56c-e1f0e1d9ab0f" class=""><br/>This framing steers our attention towards reconfiguring our goal of building software systems intelligent enough to figure out the steps needed to produce a desired outcome in service of the operator‚Äôs broader vision. As Shan Carter and Michael Nielsen explain succinctly in¬†<br/><a href="https://distill.pub/2017/aia/"><em>Using Artificial Intelligence to Augment Human Intelligence</em></a><em>,</em>¬†‚ÄúIntelligence Augmentation (IA), is all about empowering humans with tools that make them more capable and more intelligent, while Artificial Intelligence (AI) has been about removing humans fully from the loop.‚Äù</p><p id="97d09609-c37d-45be-b885-f1ad92c9025a" class="">Framing our approach to building software in a way where LLMs should give you more control instead of remaining a black box unlocks a lot of different pathways in how we craft interfaces.</p><p id="e3fa1bec-3b07-494a-8812-30a7358cac43" class="">
</p><hr id="7ac5e42f-10fc-4238-a5e9-f081b754bdd3"/><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1049f5af-7d47-405d-9843-6ee4b1726e8b"><div style="font-size:1.5em"><span class="icon">üöß</span></div><div style="width:100%">Unfortunately, you cannot take <code>Doneth</code> for a spin right now because GPT-3 and its associated APIs have since been sunset ‚éØ and I have not refactored the codebase to use GPT-3.5 or above yet! That‚Äôs my to-do for 2024.</div></figure><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="9840841c-af43-4116-8c92-2c0b38ddce06"><div style="font-size:1.5em"><span class="icon">üçß</span></div><div style="width:100%">In November 2022, I gave a talk at DevFest Kolkata titled <a href="https://github.com/GeekBoySupreme/talks/blob/master/(re)Learning%20riding%20a%20bicycle.pptx.pdf"><em>(re)learning riding the bicycle</em></a><em> </em>that explored a bunch of<strong><em> </em></strong>concepts around leveraging LLMs to do a lot of funky experiments. You can find the slides for the talk <a href="https://github.com/GeekBoySupreme/talks/blob/master/(re)Learning%20riding%20a%20bicycle.pptx.pdf">here</a> ‚ÜóÔ∏è</div></figure>
</article>

</body></html>